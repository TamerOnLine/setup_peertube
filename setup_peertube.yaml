#cloud-config

package_update: true
package_upgrade: true

write_files:
  - path: /root/pt.env
    permissions: '0644'
    content: |
      # ðŸ”§ VARIABLES (edit as needed)
      PT_DOMAIN=""                 # leave empty to auto-detect server IP
      PT_HTTPS="false"             # true/false (must be false when no domain)
      PT_WEB_PORT="9000"

      PT_DB_HOST="127.0.0.1"
      PT_DB_PORT="5432"
      PT_DB_USER="peertube"
      PT_DB_PASS="CHANGE_ME_DB_PASS"   # <-- change this
      PT_DB_NAME="peertube"
      PT_DB_SSL="false"

      # SMTP (optional)
      PT_SMTP_HOST=""
      PT_SMTP_PORT="587"
      PT_SMTP_USER=""
      PT_SMTP_PASS=""
      PT_SMTP_TLS="true"
      PT_SMTP_DISABLE_STARTTLS="false"
      PT_FROM_ADDRESS=""               # empty => auto no-reply@<domain or IP>

      PT_INSTANCE_NAME="MyTube"
      PT_INSTANCE_DESC="Public PeerTube instance"
      PT_LANGUAGES="en,de,ar"
      PT_RESOLUTIONS="720p,1080p"
      PT_ENABLE_SIGNUP="false"
      PT_REQUIRES_APPROVAL="true"
      PT_REQUIRES_EMAIL_VERIFICATION="false"
      PT_KEEP_ORIGINAL="false"
      PT_HLS_ENABLED="true"
      PT_WEB_VIDEOS_ENABLED="false"

  - path: /root/setup_peertube.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      import os, sys, re, shlex, subprocess
      from pathlib import Path
      from textwrap import dedent

      DEFAULTS = {
          "domain":               os.environ.get("PT_DOMAIN", ""),
          "https":                os.environ.get("PT_HTTPS", "false"),
          "web_port":             int(os.environ.get("PT_WEB_PORT", "9000")),
          "pt_user":              os.environ.get("PT_USER", "peertube"),
          "pt_home":              os.environ.get("PT_HOME", "/var/www"),
          "db_host":              os.environ.get("PT_DB_HOST", "127.0.0.1"),
          "db_port":              int(os.environ.get("PT_DB_PORT", "5432")),
          "db_user":              os.environ.get("PT_DB_USER", "peertube"),
          "db_pass":              os.environ.get("PT_DB_PASS", "CHANGE_ME_DB_PASS"),
          "db_name":              os.environ.get("PT_DB_NAME", "peertube"),
          "db_ssl":               os.environ.get("PT_DB_SSL", "false"),
          "smtp_host":            os.environ.get("PT_SMTP_HOST", ""),
          "smtp_port":            int(os.environ.get("PT_SMTP_PORT", "587")),
          "smtp_user":            os.environ.get("PT_SMTP_USER", ""),
          "smtp_pass":            os.environ.get("PT_SMTP_PASS", ""),
          "smtp_tls":             os.environ.get("PT_SMTP_TLS", "true"),
          "smtp_disable_starttls":os.environ.get("PT_SMTP_DISABLE_STARTTLS", "false"),
          "from_address":         os.environ.get("PT_FROM_ADDRESS", ""),
          "instance_name":        os.environ.get("PT_INSTANCE_NAME", "MyTube"),
          "instance_desc":        os.environ.get("PT_INSTANCE_DESC", "Public PeerTube instance"),
          "languages":            os.environ.get("PT_LANGUAGES", "en,de,ar"),
          "resolutions":          os.environ.get("PT_RESOLUTIONS", "720p,1080p"),
          "enable_signup":        os.environ.get("PT_ENABLE_SIGNUP", "false"),
          "requires_approval":    os.environ.get("PT_REQUIRES_APPROVAL", "true"),
          "requires_email_verification": os.environ.get("PT_REQUIRES_EMAIL_VERIFICATION", "false"),
          "keep_original":        os.environ.get("PT_KEEP_ORIGINAL", "false"),
          "hls_enabled":          os.environ.get("PT_HLS_ENABLED", "true"),
          "web_videos_enabled":   os.environ.get("PT_WEB_VIDEOS_ENABLED", "false"),
      }

      PEERTUBE_REPO = "https://github.com/Chocobozzz/PeerTube.git"
      PEERTUBE_BRANCH = "production"
      SITE_FILE = "/etc/nginx/sites-available/peertube"
      SERVICE_FILE = "/etc/systemd/system/peertube.service"

      def log(m): print(f"[i] {m}")
      def warn(m): print(f"[!] {m}", file=sys.stderr)

      def run(cmd, check=True, shell=False, user=None, cwd=None):
          """Run a command (optionally as another user)."""
          if isinstance(cmd, str) and not shell:
              cmd_list = shlex.split(cmd); cmd_show = cmd
          elif isinstance(cmd, list):
              cmd_list = cmd; cmd_show = " ".join(shlex.quote(c) for c in cmd)
          else:
              cmd_list = cmd; cmd_show = cmd if isinstance(cmd,str) else " ".join(cmd)
          if user and os.geteuid() == 0:
              inner = f"cd {shlex.quote(str(cwd))} && {cmd_show}" if cwd else cmd_show
              full = ["sudo","-u",user,"bash","-lc",inner]
              print("$ "+" ".join(shlex.quote(s) for s in full))
              return subprocess.run(full, check=check, text=True)
          else:
              if cwd: print(f"(cd {cwd})$ {cmd_show}")
              else: print(f"$ {cmd_show}")
              return subprocess.run(cmd_list if not shell else cmd, check=check, shell=shell, text=True, cwd=cwd)

      def require_root():
          if os.geteuid()!=0:
              warn("Run as root."); sys.exit(1)

      def is_ip(host): return bool(re.match(r"^\d{1,3}(\.\d{1,3}){3}$", host))
      def bool_str(x):
          if isinstance(x,bool): return "true" if x else "false"
          return "true" if str(x).strip().lower() in {"1","true","yes","y","on"} else "false"

      def ensure_packages():
          log("Update & base packages...")
          run("apt-get update -y")
          run("DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget gnupg lsb-release unzip git vim ca-certificates ufw python3")
          log("Install Node.js 20 + Yarn/Corepack...")
          run("curl -fsSL https://deb.nodesource.com/setup_20.x | bash -", shell=True)
          run("apt-get install -y nodejs")
          run("corepack enable", check=False)
          if subprocess.run(["bash","-lc","command -v yarn >/dev/null 2>&1"]).returncode!=0:
              run("npm install -g yarn", check=False)
          log("Install PostgreSQL/Redis/ffmpeg/Nginx/Certbot...")
          run("apt-get install -y postgresql postgresql-contrib redis-server ffmpeg nginx certbot python3-certbot-nginx")
          run("systemctl enable --now redis-server postgresql nginx", check=False)

      def ensure_user(user, home):
          import pwd
          try:
              pwd.getpwnam(user); log(f"user {user} exists")
          except KeyError:
              run(["adduser","--disabled-password","--gecos","",user])
          Path(home).mkdir(parents=True, exist_ok=True)

      def ensure_db(user, password, dbname):
          log("Configure PostgreSQL...")
          ret = subprocess.run(f"sudo -u postgres psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='{user}'\"",
                               shell=True, text=True, capture_output=True)
          if "1" not in ret.stdout:
              run(f"sudo -u postgres psql -c \"CREATE USER {user} WITH PASSWORD '{password}';\"", shell=True)
          ret = subprocess.run(f"sudo -u postgres psql -tAc \"SELECT 1 FROM pg_database WHERE datname='{dbname}'\"",
                               shell=True, text=True, capture_output=True)
          if "1" not in ret.stdout:
              run(f"sudo -u postgres psql -c \"CREATE DATABASE {dbname} OWNER {user};\"", shell=True)

      def gen_secret_hex(n=32): return os.urandom(n).hex()

      def detect_ip_fallback():
          """Return first IPv4 from `hostname -I`, or 127.0.0.1."""
          try:
              out = subprocess.check_output(
                  ["bash","-lc","hostname -I | awk '{print $1}'"], text=True
              ).strip()
              if out:
                  return out
          except Exception:
              pass
          return "127.0.0.1"

      def build_production_yaml(cfg, secret):
          langs = [s.strip() for s in str(cfg["languages"]).split(",") if s.strip()]
          ress  = [s.strip() for s in str(cfg["resolutions"]).split(",") if s.strip()]
          res_keys = ["0p","144p","240p","360p","480p","720p","1080p","1440p","2160p"]
          res_map = {k: ("true" if k in ress else "false") for k in res_keys}
          langs_yaml = "\n".join([f"    - {l}" for l in langs]) if langs else "    # - en\n    # - de\n    # - ar"
          # If FROM_ADDRESS empty â†’ auto from domain/IP
          dom_or_ip = cfg['domain'] if cfg['domain'] else detect_ip_fallback()
          from_addr = cfg["from_address"] or f"PeerTube <no-reply@{dom_or_ip}>"
          return f"""# Generated by cloud-init
      webserver:
        https: {bool_str(cfg['https'])}
        hostname: '{dom_or_ip}'
        port: {int(cfg['web_port'])}
      secrets:
        peertube: '{secret}'
      database:
        hostname: '{cfg['db_host']}'
        port: {int(cfg['db_port'])}
        ssl: {bool_str(cfg['db_ssl'])}
        username: '{cfg['db_user']}'
        password: '{cfg['db_pass']}'
        name: '{cfg['db_name']}'
      redis:
        hostname: '127.0.0.1'
        port: 6379
        auth: null
        db: 0
      smtp:
        transport: smtp
        hostname: {('null' if not cfg['smtp_host'] else "'" + cfg['smtp_host'] + "'")}
        port: {int(cfg['smtp_port'])}
        username: {('null' if not cfg['smtp_user'] else "'" + cfg['smtp_user'] + "'")}
        password: {('null' if not cfg['smtp_pass'] else "'" + cfg['smtp_pass'] + "'")}
        tls: {bool_str(cfg['smtp_tls'])}
        disable_starttls: {bool_str(cfg['smtp_disable_starttls'])}
        ca_file: null
        from_address: '{from_addr}'
      signup:
        enabled: {bool_str(cfg['enable_signup'])}
        limit: 10
        minimum_age: 16
        requires_approval: {bool_str(cfg['requires_approval'])}
        requires_email_verification: {bool_str(cfg['requires_email_verification'])}
        filters:
          cidr:
            whitelist: []
            blacklist: []
      instance:
        name: '{cfg['instance_name']}'
        short_description: '{cfg['instance_name']}'
        description: '{cfg['instance_desc']}'
        default_client_route: '/videos/trending'
        is_nsfw: false
        default_nsfw_policy: 'do_not_list'
        languages:
      {langs_yaml}
      user:
        history:
          videos:
            enabled: true
        video_quota: -1
        video_quota_daily: -1
        default_channel_name: 'Main $1 channel'
      transcoding:
        enabled: true
        original_file:
          keep: {bool_str(cfg['keep_original'])}
        allow_additional_extensions: true
        allow_audio_files: true
        remote_runners:
          enabled: false
        threads: 1
        concurrency: 1
        profile: 'default'
        resolutions:
          0p: {res_map['0p']}
          144p: {res_map['144p']}
          240p: {res_map['240p']}
          360p: {res_map['360p']}
          480p: {res_map['480p']}
          720p: {res_map['720p']}
          1080p: {res_map['1080p']}
          1440p: {res_map['1440p']}
          2160p: {res_map['2160p']}
        always_transcode_original_resolution: true
        web_videos:
          enabled: {bool_str(cfg['web_videos_enabled'])}
        hls:
          enabled: {bool_str(cfg['hls_enabled'])}
      live:
        enabled: false
      log:
        level: 'info'
        rotation:
          enabled: true
          max_file_size: 12MB
          max_files: 20
        log_http_requests: true
      contact_form:
        enabled: true
      """

      def configure_nginx(domain, web_port):
          # Use '_' wildcard if domain empty; otherwise use the provided domain (or IP)
          server_name = domain if domain else "_"
          conf = dedent(f"""
          server {{
            server_name {server_name};
            listen 80;
            listen [::]:80;
            location / {{
              proxy_pass http://127.0.0.1:{web_port};
              proxy_http_version 1.1;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_connect_timeout 600s;
              proxy_send_timeout    600s;
              proxy_read_timeout    600s;
              send_timeout          600s;
            }}
          }}
          """).strip()+"\n"
          Path("/etc/nginx/sites-available/peertube").write_text(conf, encoding="utf-8")
          if not Path("/etc/nginx/sites-enabled/peertube").exists():
              os.symlink("/etc/nginx/sites-available/peertube","/etc/nginx/sites-enabled/peertube")
          run("nginx -t"); run("systemctl reload nginx")

      def enable_https(domain, https):
          if bool_str(https)!="true": return
          if not domain:
              warn("HTTPS=true but DOMAIN is empty; skipping Certbot.")
              return
          if is_ip(domain):
              warn("HTTPS=true but DOMAIN is an IP; skipping Certbot.")
              return
          run(f"certbot --nginx -d {shlex.quote(domain)} --non-interactive --agree-tos -m admin@{shlex.quote(domain)}", check=False)

      def write_systemd(pt_dir, pt_user):
          unit = dedent(f"""
          [Unit]
          Description=PeerTube
          After=postgresql.service redis-server.service

          [Service]
          User={pt_user}
          WorkingDirectory={pt_dir}
          Environment=NODE_ENV=production
          ExecStart=/usr/bin/node dist/server
          Restart=always
          RestartSec=10

          [Install]
          WantedBy=multi-user.target
          """).strip()+"\n"
          Path("/etc/systemd/system/peertube.service").write_text(unit, encoding="utf-8")
          run("systemctl daemon-reload")
          run("systemctl enable peertube", check=False)
          run("systemctl restart peertube", check=False)
          run("sleep 3", shell=True)
          run("systemctl status peertube --no-pager -n 50", check=False)

      def ufw_open():
          if subprocess.run(["bash","-lc","command -v ufw >/dev/null 2>&1"]).returncode==0:
              run("ufw allow 80/tcp", check=False)
              run("ufw allow 443/tcp", check=False)

      def main():
          require_root()
          # Export env vars from /root/pt.env
          if Path("/root/pt.env").exists():
              for line in Path("/root/pt.env").read_text(encoding="utf-8").splitlines():
                  if not line.strip() or line.strip().startswith("#"): continue
                  if "=" in line:
                      k,v = line.split("=",1); os.environ[k.strip()] = v.strip().strip('"').strip("'")
          cfg = DEFAULTS.copy()

          # Auto-detect IP if domain is empty
          if not cfg["domain"]:
              cfg["domain"] = detect_ip_fallback()

          pt_user = cfg["pt_user"]; pt_home = Path(cfg.get("pt_home","/var/www")); pt_dir = pt_home/"peertube"
          ensure_packages()
          ensure_user(pt_user, str(pt_home))
          ensure_db(cfg["db_user"], cfg["db_pass"], cfg["db_name"])

          if not pt_dir.exists():
              run(f"git clone -b {PEERTUBE_BRANCH} {PEERTUBE_REPO} {shlex.quote(str(pt_dir))}", user=pt_user)
          else:
              run("git fetch --all", user=pt_user, cwd=str(pt_dir))
              run(f"git reset --hard origin/{PEERTUBE_BRANCH}", user=pt_user, cwd=str(pt_dir))
          run("yarn install --production --pure-lockfile", user=pt_user, cwd=str(pt_dir))

          secret = gen_secret_hex()
          yaml = build_production_yaml(cfg, secret)
          cfg_path = pt_dir/"config"/"production.yaml"
          cfg_path.parent.mkdir(parents=True, exist_ok=True)
          cfg_path.write_text(yaml, encoding="utf-8")
          os.chmod(cfg_path, 0o600)
          try:
              import pwd, grp
              os.chown(str(cfg_path), pwd.getpwnam(pt_user).pw_uid, grp.getgrnam(pt_user).gr_gid)
          except Exception:
              pass

          configure_nginx(cfg["domain"], cfg["web_port"])
          enable_https(cfg["domain"], cfg["https"])
          write_systemd(str(pt_dir), pt_user)
          ufw_open()

          proto = "https" if bool_str(cfg["https"])=="true" else "http"
          print("\n==== DONE ====")
          print(f"URL: {proto}://{cfg['domain']}")
          print("systemctl status peertube")
          print("journalctl -u peertube -n 100 --no-pager")

      if __name__ == "__main__":
          main()

runcmd:
  - [ bash, -lc, 'echo "[i] Loading variables..."' ]
  - [ bash, -lc, 'set -a; source /root/pt.env; set +a' ]
  - [ bash, -lc, 'apt-get update -y' ]
  - [ bash, -lc, 'apt-get install -y python3' ]
  - [ bash, -lc, 'python3 /root/setup_peertube.py' ]
